#!/usr/bin/env python3

"""
Module responsible for collecting whole dialled number and adding command to msg queue
"""

import RPi.GPIO as GPIO
import time
import queue
import logging

handset_pin = 13
rotary_dial_pin = 6
bounce_time = 30

GPIO.setmode(GPIO.BCM)
GPIO.setup(rotary_dial_pin, GPIO.IN)
GPIO.setup(handset_pin, GPIO.IN)


def ticks_to_digit(tick_count):
    """
    Converts tick number to digit.

    For my phone (W48mT - https://en.wikipedia.org/wiki/W48_(telephone)) rotary dial tick twice for single dial hole.
    If one (and at most one) tick is missing, proper digit still can be calculated thanks to +1 in formula.
    Unfortunately 1 tick which sometimes is generated spuriously on RPi will be also treated as '1'...
    :param tick_count: number of ticks generated by rotary dial for single digit
    :return: calculated digit
    """
    return str(((tick_count+1)//2) % 10)


def collect_number(queue):
    """
    Collects whole phone number

    If time between ticks <= 0.5s -> those are the ticks from the same digit
    If time between ticks > 0.5s and < 5s -> second tick is from next digit
    If there is gap <= 5s -> collecting stops and whole number is added to msg queue
    :param queue: message queue
    """
    logger = logging.getLogger(__name__)
    logger.info("Starting collection loop")
    while True:
        # wait (forever) for the first tick - no timeout
        channel = GPIO.wait_for_edge(rotary_dial_pin, GPIO.FALLING, bouncetime=bounce_time)
        tick_count = 1
        number = ''
        start_time = time.time()
        while channel is not None:
            # 5 secs after last tick call will be initiated
            channel = GPIO.wait_for_edge(rotary_dial_pin, GPIO.FALLING, bouncetime=bounce_time, timeout=5000)
            if channel is not None:
                end_time = time.time()
                if end_time - start_time <= 0.5:
                    # gap between ticks smaller that 0.5s means that those are still ticks for the same digit
                    tick_count += 1
                else:
                    # bigger gap means that new digit just started, so previous was finished and can be stored
                    # if handset is up
                    if GPIO.input(handset_pin):
                        number += ticks_to_digit(tick_count)
                        tick_count = 1
                    else:
                        number = ''
                start_time = end_time
            else:
                # last digit is stored after longer gap if handset is up
                if GPIO.input(handset_pin):
                    number += ticks_to_digit(tick_count)
                    logger.info(f"Number to call collected: {number}")
                    queue.put(number)
                else:
                    number = ''


if __name__ == '__main__':
    queue = queue.Queue()
    collect_number(queue)
