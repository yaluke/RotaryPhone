#!/usr/bin/env python3

"""
Simple script which collects whole number to call
"""

import RPi.GPIO as GPIO
import time

rotary_dial_pin = 6
bounce_time = 30

GPIO.setmode(GPIO.BCM)
GPIO.setup(rotary_dial_pin, GPIO.IN)

def ticks_to_digit(tick_count):
	"""
	Converts tick number to digit. For my phone (W48mT - https://en.wikipedia.org/wiki/W48_(telephone)) rotary dial tick
	twice for single dial hole. If one (at at most one) tick is missing, proper digit still can be calculated thanks to
	+1 in formula. Unfortunatelly 1 tick which sometimes is generated spuriosly on RPi will be also treated as '1'...
	:param tick_count: number of ticks generated by rotary dial for single digit
	:return: calculated digit
	"""
	return str( ((tick_count+1)//2)%10 )

def loop():
	while True:
		# wait (forever) for the first tick - no timeout
		channel = GPIO.wait_for_edge(rotary_dial_pin, GPIO.FALLING, bouncetime=bounce_time)
		tick_count = 1
		number = ''
		start_time = time.time()
		while channel is not None:
			# 5 secs after last tick call will be initiated
			channel = GPIO.wait_for_edge(rotary_dial_pin, GPIO.FALLING, bouncetime=bounce_time, timeout=5000)
			if channel is not None:
				end_time = time.time()
				if end_time - start_time <= 0.5:
					# gap between ticks smaller that 0.5s means that those are still ticks for the same digit
					tick_count += 1
				else:
					# bigger gap means that new digit just started, so previous was finished and can be stored
					number += ticks_to_digit(tick_count)
					tick_count = 1
				start_time = end_time
			else:
				# last digit is stored after longer gap
				number += ticks_to_digit(tick_count)
				print(f"Chosen number is {number}")


loop()
